import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.nio.file.Paths;
import java.util.Objects;

public class MangaSettings
{
	public static final String SLASH = ( System.getProperty( "os.name" ).indexOf( "Windows" ) == 0 ) ? "\\" : "/";
	private static final String DEBUG_TAG = "debug-";
	private final File propfile;
	private final String[][] PROPERTIES_SCHEMA = new String[][]{ //4 columns, col 0 - property name, col 1 - property value, col 2 - required? (optional, defaults to yes), col 3 - comment (optional)
	                                                             { "data_saver", "false", "yes", "MangaDex's Data Saver feature" },
	                                                             { "temp_folder", "manga", "yes", "The folder where the raw images will be stored, with folders for each series inside; these are deleted once archived successfully" },
	                                                             { "image_filename_format_symbol", "!", "yes", "Character to be replaced with the image number in the image filename" },
	                                                             { "image_filename_format", "image!", "yes", "The format of the image file names; the character from 'image filename format symbol' will be replaced with the image name" },
	                                                             { "percent_format", "##.00", "yes", "The format of the percentage outputs" },
	                                                             { "image_file_extension", ".jpg", "yes", "The extension of the image files; do not change from .jpg unless MangaDex changes their format" },
	                                                             { "manga_file_extension", ".cbz", "yes", "The extension of the archived manga, so far only .cbz is supported" },
	                                                             { "split_by_volume", "false", "no", "Generates one massive file for the entire series if false, or one file per volume if true" },
	                                                             { "multithreaded", "true", "yes", "Enables multithreaded downloads" },
	                                                             { "max_connections", "10", "yes", "I recommend a maximum of 10 simultaneous connections" },
	                                                             { "destination", "manga", "yes", "Where the final manga file will be output" },
	                                                             { "library_updater_command", "", "no", "Command to use to update your library, relative to the destination folder; not required" },
	                                                             { "language", "en", "yes", "MangaDex language identifier for your language" },
	                                                             { "clipboard", "false", "no", "Use UUID from Clipboard" },
	                                                             { "archive", "true", "yes", "Archive the resulting images?" }
	};
	private final String[][] BOOL_VALUES = new String[][]{ { "true", "false" },
	                                                       { "yes", "no", },
	                                                       { "1", "0" } }; //trues in [row][0], falses in [row][1]; assume all lowercase
	private MangaProperties properties = null;
	
	public MangaSettings( File propfile_in )
	{
		propfile = propfile_in;
		
		try
		{
			if( !propfile.exists() )
			{
				propfile.createNewFile();
			}
			else
			{
				properties = new MangaProperties();
				properties.load( new FileInputStream( propfile ) );
			}
		}
		catch( IOException e )
		{
			e.printStackTrace();
		}
		
		if( properties == null )
		{
			setDefaultProperties();
			MangaDownloader.warning( "Settings file " + propfile + " was not present, so it was generated by default." );
		}
		
		if( getDebug( "enabled" ) != null && getDebug( "enabled" ).equals( "true" ) )
		{
			for( Object keyin : properties.keySet() )
			{
				String key = keyin.toString();
				String value = properties.getProperty( key );
				System.out.println( key + " -----> " + value );
			}
		}
		
		checkSettings();
	}
	
	private void setDefaultProperties()
	{
		properties = new MangaProperties();
		
		properties.addHeader( "WARNING 1: You must escape the proper characters, including the following: !#=:\\" );
		properties.addHeader( "WARNING 2: If the series is incomplete or has duplicate chapters on MangaDex, so too will the output of this program." );
		properties.addHeader( "To find the MangaDex UUID, find the Manga in MangaDex and find the UUID in the URL." );
		
		for( String[] strings : PROPERTIES_SCHEMA )
		{
			String key = strings[0];
			String value = strings[1];
			
			if( strings.length >= 4 )
			{
				String comment = strings[3];
				properties.setProperty( key, value, comment );
			}
			
			properties.setProperty( key, value );
		}
		
		try
		{
			properties.store( new FileOutputStream( propfile ) );
		}
		catch( IOException e )
		{
			e.printStackTrace();
		}
	}
	
	public String get( String key )
	{
		checkKey( key );
		
		if( properties.getProperty( key ) == null && isPropertyRequired( key ) )
		{
			return invalidProperty( key );
		}
		
		return properties.getProperty( key );
	}
	
	public String getDebug( String key )
	{
		return properties.getProperty( DEBUG_TAG + key );
	}
	
	public boolean getBool( String key )
	{
		checkKey( key );
		String property = properties.getProperty( key );
		
		if( property == null && !isPropertyRequired( key ) )
		{
			return isTrue( getDefault( key ) );
		}
		else if( property == null && isPropertyRequired( key ) )
		{
			return isTrue( invalidProperty( key ) );
		}
		
		if( !isBooleanValue( property ) )
		{
			if( isPropertyRequired( key ) )
			{
				return isTrue( invalidProperty( key, true ) );
			}
			else
			{
				return isTrue( getDefault( key ) );
			}
		}
		else
		{
			return isTrue( properties.getProperty( key ) );
		}
	}
	
	public int getInt( String key )
	{
		checkKey( key );
		
		try
		{
			return Integer.parseInt( properties.getProperty( key ) );
		}
		catch( NumberFormatException e )
		{
			if( isPropertyRequired( key ) )
			{
				return Integer.parseInt( invalidProperty( key ) );
			}
			else
			{
				return Integer.MIN_VALUE;
			}
		}
	}
	
	public char getChar( String key )
	{
		checkKey( key );
		String value = properties.getProperty( key );
		
		if( value == null || value.length() != 1 )
		{
			if( isPropertyRequired( key ) )
			{
				return invalidProperty( key ).charAt( 0 );
			}
			else
			{
				return Objects.requireNonNull( getDefault( key ) ).charAt( 0 );
			}
		}
		
		return properties.getProperty( key ).charAt( 0 );
	}
	
	public File getFile( String key )
	{
		checkKey( key );
		
		try
		{
			return Paths.get( properties.getProperty( key ) ).toFile();
		}
		catch( InvalidPathException | NullPointerException e )
		{
			if( isPropertyRequired( key ) )
			{
				return Paths.get( invalidProperty( key ) ).toFile();
			}
			else
			{
				return null;
			}
		}
	}
	
	private void checkKey( String key )
	{
		if( key == null )
		{
			MangaDownloader.fatalError( "Null key" );
			System.exit( 0 );
		}
		
		String value = properties.getProperty( key );
		
		if( value == null )
		{
			if( isPropertyRequired( key ) )
			{
				System.out.println( key + " is required, but not present" );
			}
		}
	}
	
	private String invalidProperty( String key, boolean fatal )
	{
		String default_value = getDefault( key );
		
		if( default_value == null )
		{
			MangaDownloader.fatalError( "No default value for " + key );
		}
		
		if( !fatal )
		{
			MangaDownloader.warning( "Setting for " + key + " invalid, using default of '" + default_value + "'" );
		}
		else
		{
			MangaDownloader.fatalError( "Setting for " + key + " is invalid and required" );
			System.exit( 0 );
		}
		
		return default_value;
	}
	
	private String invalidProperty( String key ) //outputs an error message and returns the default; primarily for making code prettier and keeping the error message in one place
	{
		return invalidProperty( key, false );
	}
	
	private String getDefault( String propkey )
	{
		for( String[] strings : PROPERTIES_SCHEMA )
		{
			String searchkey = strings[0];
			String value = strings[1];
			
			if( searchkey.equals( propkey ) )
			{
				return value;
			}
		}
		
		return null;
	}
	
	private boolean isBooleanValue( String value )
	{
		for( String[] bool_value : BOOL_VALUES )
		{
			if( value.toLowerCase().equals( bool_value[0] ) || value.toLowerCase().equals( bool_value[1] ) )
			{
				return true;
			}
		}
		
		return false;
	}
	
	private boolean isTrue( String value )
	{
		for( String[] bool_value : BOOL_VALUES )
		{
			if( value.toLowerCase().equals( bool_value[0] ) ) //trues are column 0
			{
				return true;
			}
		}
		
		return false;
	}
	
	private boolean doesPropertyExist( String property )
	{
		return properties.getProperty( property ) == null;
	}
	
	private boolean isPropertyRequired( String propkey )
	{
		if( !doesPropertyExist( propkey ) )
		{
			return false;
		}
		
		for( String[] strings : PROPERTIES_SCHEMA )
		{
			String searchkey = strings[0];
			
			boolean required = false;
			
			if( strings.length >= 3 )
			{
				//Required column must match this to be considered required
				String REQUIRED_MARKER = "yes";
				required = strings[2].toLowerCase().equals( REQUIRED_MARKER );
			}
			
			if( searchkey.equals( propkey ) )
			{
				return required;
			}
		}
		
		return true;
	}
	
	private void checkSettings()
	{
		for( String[] strings : PROPERTIES_SCHEMA )
		{
			String key = strings[0];
			
			if( properties.get( key ) == null )
			{
				if( isPropertyRequired( key ) )
				{
					MangaDownloader.fatalError( key + " is required and not present" );
					System.exit( 0 );
				}
			}
		}
	}
}
